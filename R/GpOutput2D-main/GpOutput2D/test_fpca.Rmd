---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r warning = FALSE}
library(miceadds)
library(waveslim)
library(dplyr)
library(foreach)
library(DiceKriging)
library(OpenStreetMap)
library(ggplot2)
library(orthogonalsplinebasis)
library(pracma)
library(abind)
library(osmdata)

```

On va importer l'ensemble des fonctions dans le dossier R de GpOutput2D.

On va également importer les données de simulations sans rupture. La dimension des cartes de $194\times 202$, on va créer des cartes de $256\times 256$ pixels (la dimension est alors une puissance de 2), en ajoutant des 0

```{r warning = FALSE}
setwd("C:/Users/sire-cha/Documents/GpOutput2D-main/GpOutput2D")

source.all("C:/Users/sire-cha/Documents/GpOutput2D-main/GpOutput2D/R")

load("~/math4flood/Data_Cas_Maritime/Boucholeurs_NOFailure_Charlie.RData")

#L'argument only_set va nous permettre de passer de la première à la deuxième approche
doe_sans_rupture = doe
HE_sans_rupture = HE
HE_sans_rupture = abind(HE_sans_rupture,array(0, c(256-194,202 , 500)), along = 1)
HE_sans_rupture = abind(HE_sans_rupture,array(0, c(256,256-202 , 500)), along = 2)
area_sans_rupture = Area/max(Area)

load("C:/Users/sire-cha/Documents/Quantization/coord.RData")
## background
## background
map <- openmap(c(46.03185,-1.096214),
               c(46.07718,-1.033486),type="osm")

## coordinates transformation
map.latlon <- openproj(map, projection = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")



```

Pretty_map est une fonction pour ploter une matrice avec une carte géographique en fond
```{r}
pretty_map = function(gamma_k, only_set = FALSE){
  x = NULL
  y = NULL
  he = NULL
  c = 0
  for (i in 1:length(lon)){
  	for (j in 1:length(lat)){
  		c<-c+1
  		x[c]<-lon[i]
  		y[c]<-lat[j]
  		he[c]<-gamma_k[i,j]
  	}
  }

    dat_lonlat<-data.frame(lon=x,lat=y,rmse=he)
  if (only_set){p = OpenStreetMap::autoplot.OpenStreetMap(map.latlon)+geom_raster(data = dat_lonlat , aes(x = lon, y = lat, fill = rmse)) + scale_fill_manual(values = c("transparent","#453781FF")) + scale_alpha(range = c(0.15, 0.65), guide = "none")+theme_bw()}
  else{
    dat_lonlat[which(he == 0), "rmse"] = NA
    p = OpenStreetMap::autoplot.OpenStreetMap(map.latlon)+geom_raster(data = dat_lonlat , aes(x = lon, y = lat, fill = rmse)) + scale_fill_continuous(type = "viridis",na.value = "transparent", direction = -1) +
     scale_alpha(range = c(0.15, 0.65), guide = "none")+theme_bw()
    }
  print(p)
}
```

Nous avons une base de données avec 257 "non indondations" (aire nulle) et 243 inondations avec une aire non nulle.

On va alors se donner une base d'entrainement de 400 simulations, dont la moitié correspondent à des inondations avec une aire non nulle

```{r}
aires_nulles = which(area_sans_rupture == 0)
aires_non_nulles = which(area_sans_rupture > 0)
set.seed(10)
indices_training = c(sample(aires_nulles, 200), sample(aires_non_nulles, 200))
indices_test = setdiff(1:500, indices_training)

X_training = doe_sans_rupture[indices_training,]
X_test = doe_sans_rupture[indices_test,]



```

On va maintenant créer une fonction fpca_func qui prédit en fonction de la méthode choisie (wavelets ou Bsplines), une carte d'inondations en chaque point de la base de test. ncoeff est le nombre de coefficients à garder (les coeffs d'énergie la plus importante) juste avant la pca, et rank et le nombre de dimensions après la pca

La fonction rmse_func calcule la RMSE en chaque pixel, en prenant en entrée la sortie de la fonction fpca_func

```{r}

fpca_func = function(method, ncoeff, rank){
  if (method == "wavelets"){
    fp = Fpca2d.Wavelets(HE_sans_rupture[,,indices_training], wf = "d4", boundary = "periodic", J = 1, ncoeff = ncoeff, rank = rank)
  }
  else{fp = Fpca2d.Bsplines(HE_sans_rupture[,,indices_training], z1 = seq(0,1,l = 256), z2 = seq(0,1, l = 256), z1.knots = seq(0,1,l=40), z2.knots = seq(0,1,l=40), ncoeff = ncoeff, expand_knots = F, rank = rank)}
  
  model = km_Fpca2d(formula = ~1, design = data.frame(x = X_training), response = fp, covtype = "matern5_2", coef.trend = NULL, coef.var = NULL, coef.cov = NULL, control = list(trace = 0))
  pred = predict.km_Fpca2d(object = model, newdata = X_test, type = "UK", compute = FALSE)
  return(pred)

}


rmse_func = function(pred){
  mse = (pred$mean - HE_sans_rupture[,,indices_test])^2
  rmse = data.frame(matrix(0,ncol = 256, nrow = 256))
  for (k in 1:dim(mse)[3]){
    rmse = rmse + mse[,,k]
  }
  
  rmse = rmse/dim(mse)[3]
  rmse = sqrt(rmse)
  
  rmse = rmse[1:194,1:202,]
  return(rmse)
}



```

# Wavelets

On va donc utiliser les 2 fonctions pour une base d'ondelettes avec les paramètres choisis dans le papier : ncoeff = 4000 et npc = 2 
```{r}
pred_wavelets = fpca_func("wavelets", ncoeff = 4000, rank = 2)
rmse_wavelets = rmse_func(pred_wavelets)

pretty_map(rmse_wavelets)


```
## B splines

On va pareil pour une base de splines avec ncoeff = 1700 et npc = 2

```{r}
pred_splines = fpca_func("bsplines", ncoeff = 1700, rank = 2)
rmse_splines = rmse_func(pred_splines)

dat_lonlat = data.frame(expand.grid(1:194,1:202))
dat_lonlat$he = unlist(rmse_splines)
dat_lonlat[which(unlist(rmse_splines) == 0), "he"] = NA
pretty_map(rmse_splines)



```
On va regarder la distribution des RMSE calculées

```{r}
df_density = data.frame(x = seq(0,1,l= 10^3), density = density(unlist(rmse_wavelets), from = 0, to = 1, n = 10^3)$y)
df_density = rbind(df_density, data.frame(x = seq(0,1,l= 10^3), density = density(unlist(rmse_splines), from = 0, to = 1, n = 10^3)$y))
df_density$method = rep(c("wavelets","splines"), each = 10^3)

ggplot(df_density) + geom_line(aes(x = x, y = density, color = method))
```
Et on plot également les boites à moustaches
```{r}
par(mfrow = c(1,2))
boxplot(unlist(rmse_wavelets))
title("Wavelets")
boxplot(unlist(rmse_splines))
title("Bsplines")


```
```{r}
aires_nulles = which(area_sans_rupture == 0)
aires_non_nulles = which(area_sans_rupture > 0)
set.seed(1)
aires_nulles_folds = sample(cut(1:length(aires_nulles), breaks = 10, labels = FALSE))
set.seed(1)
aires_non_nulles_folds = sample(cut(1:length(aires_non_nulles), breaks = 10, labels = FALSE))

folds = c(aires_nulles_folds, aires_non_nulles_folds)


#df_cv = data.frame(matrix(0, nrow = 1, ncol = 3))
list_cv = list()
it = 0
for(ncoeff in c(300,600,2000,4000, 6000)){
  for(npc in c(2,4,6)){
    it = it + 1
    print(it)
    rmse_cv = data.frame(matrix(0, nrow = 194, ncol = 202))
    for(i in 1:10){
      indices_training = c(aires_nulles, aires_non_nulles)[folds != i]
      indices_test = c(aires_nulles, aires_non_nulles)[folds == i]
      X_training = doe_sans_rupture[indices_training,]
      X_test = doe_sans_rupture[indices_test,]
      pred = fpca_func("wavelets",ncoeff = ncoeff, rank = npc)

      rmse = rmse_func(pred)

      rmse = data.frame(matrix(0,ncol = 202, nrow = 194))
      rmse_cv = rmse_cv + rmse
    
    }

    rmse_cv = rmse_cv/10
    list_cv[[it]] = rmse_cv
  }
  
}




```

```{r}
df_cv = expand.grid(npc = c(2,3,4,5,6,7,8,9,10),ncoeff = c(0.5,1,2,3,4, 5, 6))
df_cv$quantile9 = 0
for (i in 1:nrow(df_cv)){
  df_cv[i, "quantile9"] = quantile(unlist(list_cv[[i]]), 0.9)
}

ggplot(df_cv) + geom_tile(aes(npc, ncoeff, fill = quantile9))
```
```{r}
max(pred_splines$mean[1:80,1:80,])
```

```{r}

j_vec = c()
for(i in 1:3){
  gains = c()

  while(sum(gains) <= mise*(2^(n+1) -1)){
  j = 0
  tirage = 1.1
  while(j <= 4 & tirage > p){
    tirage = runif(1)
    print(tirage)

    if (tirage <= p){
      gains = c(gains, mise*(1 + 2^j*(1.7-2)))
    }
    if(tirage > p){j = j +1}
  }
  j_vec = c(j_vec, j)
  print(sum(gains))
  if(j == 5){
    print("PERDU")
    perdu = perdu +1
    break
  }
  }
}




res_objectifs = Vectorize(function())

```

```{r}
p = 0.56
coef = 1.7
alpha = 1.7*p
mise = 125
n = 4
perdu = 0
casino = function(mise, n, p, coef, objectif){
  for(i in 1:10^4){
    gains = c()
  
    while(sum(gains) <= objectif*mise*(2^(n+1) -1)){
    j = 0
    tirage = 1.1
    while(j <= n & tirage > p){
      tirage = runif(1)
      if (tirage <= p){
        gains = c(gains, mise*(1 + 2^j*(coef-2)))
      }
      if(tirage > p){j = j +1}
    }
    if(j == n+1){
      #print("PERDU")
      perdu = perdu +1
      break
    }
    }
  }
  return(perdu)
}

res_objectifs = Vectorize(function(obj){casino(mise, n, p, coef,obj)})(seq(0.1,1,l = 10))


```

```{r}
res_objectifs_2 = Vectorize(function(obj){casino(mise, 6, p, coef,obj)})(seq(0.1,1,l = 10))

plot(seq(0.1,1,l = 10), 1-res_objectifs_2/10^4)
lines(seq(0.1,1,l = 10), 1-res_objectifs/10^4)

```

